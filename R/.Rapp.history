setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst')
sourceDir <- function(path, trace = TRUE, ...) {#
   for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {#
      if(trace) cat(nm,":")           #
      source(file.path(path, nm), ...)#
      if(trace) cat("\n")#
   }#
}#
#
sourceDir("../R")#
#
# alternatively: load from GitHub#
#library(devtools)#
#install_github("fSRM", "felice303")#
#library(fSRM)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
======================================================================#
## Load Cook 2000 data set; construct three and four member data sets#
## ======================================================================#
library(foreign)#
library(reshape2)#
dat0 <- read.spss("Cook2000.sav", to.data.frame=TRUE)#
#
# create an indicator variable for the family#
dat0$fam <- 1:nrow(dat0)#
#
# convert to long format#
dat <- melt(dat0, id.vars="fam")#
#
# create indicator variables for actor, partner, and measure ##
dat$actor <- substr(dat$variable, 1, 1)#
dat$partner <- substr(dat$variable, 2, 2)#
dat$v <- substr(dat$variable, 3, 6)#
#
# bring both measures back into columns#
dat.wide <- dcast(dat, fam + actor + partner ~ v, value.var="value")#
#
## --> now we have the correct data format for the fSRM package:#
## each row is one directed relationship with multiple measures in columns#
#
# construct a three-person data set#
dat3 <- dat.wide[dat.wide$actor %in% c("c", "f", "m") & dat.wide$partner %in% c("c", "f", "m"), ]#
#
# four-person data set#
dat4 <- dat.wide
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.1 <- fSRM(dep1 ~ actor*partner | fam, dat3, fe=FALSE)#
f3.1
x <- f3.1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
library(plyr)#
	if (is.null(x$SS)) {x$SS <- standardizedSolution(x$fit, type="std.all")}#
	## The model for 4 members must have 31 free parameters and 47 df!#
	cat("----------------\n")#
	cat(paste("SRM with roles (latent) (Roles: ", paste(x$roles, collapse=", "), sep=""), "; DVs = ", x$var.id, ") :\n----------------\n")#
	cat("\nModel summary:\n----------------\n")#
	show(x$fit)#
	cat("\nModel Fit:\n----------------\n")#
	FIT <- fitmeasures(x$fit)#
	cat(paste("Chi2 (df=", FIT["df"], ") = ", round(FIT["chisq"], digits), ", p = ", round(FIT["pvalue"], digits), "\n", sep=""))#
	cat(paste("CFI = ", round(FIT["cfi"], digits), "\n", sep=""))#
	cat(paste("TLI / NNFI = ", round(FIT["tli"], digits), "\n", sep=""))#
	cat(paste("RMSEA = ", round(FIT["rmsea"], digits), " [", round(FIT["rmsea.ci.lower"], digits), ";", round(FIT["rmsea.ci.upper"], digits), "]", "; Test of close fit: p(data | true value == .05) = ", round(FIT["rmsea.pvalue"], digits), "\n", sep=""))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
digits=3
library(plyr)#
	if (is.null(x$SS)) {x$SS <- standardizedSolution(x$fit, type="std.all")}#
	## The model for 4 members must have 31 free parameters and 47 df!#
	cat("----------------\n")#
	cat(paste("SRM with roles (latent) (Roles: ", paste(x$roles, collapse=", "), sep=""), "; DVs = ", x$var.id, ") :\n----------------\n")#
	cat("\nModel summary:\n----------------\n")#
	show(x$fit)#
	cat("\nModel Fit:\n----------------\n")#
	FIT <- fitmeasures(x$fit)#
	cat(paste("Chi2 (df=", FIT["df"], ") = ", round(FIT["chisq"], digits), ", p = ", round(FIT["pvalue"], digits), "\n", sep=""))#
	cat(paste("CFI = ", round(FIT["cfi"], digits), "\n", sep=""))#
	cat(paste("TLI / NNFI = ", round(FIT["tli"], digits), "\n", sep=""))#
	cat(paste("RMSEA = ", round(FIT["rmsea"], digits), " [", round(FIT["rmsea.ci.lower"], digits), ";", round(FIT["rmsea.ci.upper"], digits), "]", "; Test of close fit: p(data | true value == .05) = ", round(FIT["rmsea.pvalue"], digits), "\n", sep=""))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
eff <- as.data.frame(parameterEstimates(x$fit))
eff
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
eff$f <- paste(eff$lhs, eff$op, eff$rhs)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
SS <- getCor(x, ops=c("~~", "~"))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
ops=c("~~", "~")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
eff <- parameterEstimates(x$fit)#
	SS <- x$SS
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs)#
	if (g != "") {#
		sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs) & (grepl(g, SS$lhs) | grepl(g, SS$rhs))#
	}#
	SS2 <- cbind(eff[sel, ], r=SS[sel, "est.std"])
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
g=""
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
eff <- parameterEstimates(x$fit)#
	SS <- x$SS#
	#sel <- SS$op %in% ops & !is.na(SS$est.std) & SS$est.std != 0 & SS$est.std < .99999 & !grepl(paste(x$var.id, collapse="|"), SS$lhs)#
	sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs)#
	if (g != "") {#
		sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs) & (grepl(g, SS$lhs) | grepl(g, SS$rhs))#
	}#
	SS2 <- cbind(eff[sel, ], r=SS[sel, "est.std"])
SS2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
is.null(SS2$label)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cbind(SS2[1:3], label="", SS2[, 4:10])
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
if (is.null(SS2$label)) {#
		SS2 <- cbind(SS2[1:3], label="", SS2[, 4:10])#
	}#
	N <- apply(SS2[, 1:3], 1, paste, collapse=" ", sep=" ")	# formula names#
	SS3 <- data.frame(component=N, label=SS2$label, round(SS2[, -c(1:4)], 3))#
	SS3$component <- as.character(SS3$component)#
	colnames(SS3) <- c("component", "label", "estimate", "se", "z", "p.value", "ci.lower", "ci.upper", "r")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
SS3[, c(1, 2, 9, 6, 3:5, 7:8)]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
get correlations between latent factors#
getCor <- function(x, ops="~~", g="") {#
	eff <- parameterEstimates(x$fit)#
	SS <- x$SS#
	#sel <- SS$op %in% ops & !is.na(SS$est.std) & SS$est.std != 0 & SS$est.std < .99999 & !grepl(paste(x$var.id, collapse="|"), SS$lhs)#
	sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs)#
	if (g != "") {#
		sel <- SS$op %in% ops & !is.na(SS$est) & !grepl(paste(x$var.id, collapse="|"), SS$rhs) & (grepl(g, SS$lhs) | grepl(g, SS$rhs))#
	}#
	SS2 <- cbind(eff[sel, ], r=SS[sel, "est.std"])#
	if (is.null(SS2$label)) {#
		SS2 <- cbind(SS2[1:3], label="", SS2[, 4:10])#
	}#
	N <- apply(SS2[, 1:3], 1, paste, collapse=" ", sep=" ")	# formula names#
	SS3 <- data.frame(component=N, label=SS2$label, round(SS2[, -c(1:4)], 3))#
	SS3$component <- as.character(SS3$component)#
	colnames(SS3) <- c("component", "label", "estimate", "se", "z", "p.value", "ci.lower", "ci.upper", "r")#
	return(SS3[, c(1, 2, 9, 6, 3:5, 7:8)])#
}#
# retrieve model syntax from fSRM object and copy it directly to the clipboard#
# TODO: pbcopy for Windows?#
model <- function(x){#
	cat(x$syntax)#
	clipboard <- pipe("pbcopy", open="w")#
	write(x$syntax, clipboard)#
	close(clipboard)#
}#
# Transform correlation to Fisher's Z#
r2Z <- function(r) {return(0.5 * log((1 + r)/(1 - r)))}#
#
# Recode  Fisher's Z to correlation#
Z2r <- function(Z) {return((exp(2*Z)-1)/(exp(2*Z)+1))}#
#
# calculate average correlation for all elemts of x which are within [-1;1].#
# I.e., out-of-bound estimates are excluded.#
meanNA <- function(x) {#
	x[is.na(x)] <- NA#
	x[x>1] <- NA#
	x[x<(-1)] <- NA#
	return(Z2r(mean(r2Z(x), na.rm=TRUE)))#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.1 <- fSRM(dep1 ~ actor*partner | fam, dat3, fe=FALSE)#
f3.1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat3, fe=FALSE)#
f3.2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f4.1 <- fSRM(dep1 ~ actor*partner | fam, dat4)#
f4.1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f4.2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat4)#
f4.2
sessionInfo()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.1.m <- fSRM(dep1 ~ actor*partner | fam, dat3, means=TRUE)
f3.1.m
summary(f3.1.m$model)
str(f3.1.m)
summary(f3.1.m$fit)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.1.m2 <- update(f3.1, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.2.m <- fSRM(dep1/dep2 ~ actor*partner | fam, dat3, means=TRUE)
f3.2.m
install.packages("lavaan")
library(lavaan)
sessionInfo()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
f3.1.m <- fSRM(dep1 ~ actor*partner | fam, dat3, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Run a Social Relations Model with roles ("Family SRM")#
#' @aliases predict, update#
#'#
#' @description#
#' Run a Social Relations Model with roles ("Family SRM")#
#'#
#' @details#
#' A model can be rerun with additional syntax using the \code{add} function:#
#' \code{s1 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2)}#
#' \code{s2 <- add(s1, "Ac ~~ Pm")}#
#'#
#' @export#
#' @param formula A formula that defines the variable names. Should be in one of following formats: (1) Single manifest dependent variable: DV ~ actor.id * partner.id | group.id, (2) Multiple indicators for dependent variable: DV1/DV2/DV3 ~ actor.id * parter.id | group.id.#
#' @param data A data frame with all variables defined by \code{formula}. Must be in long format where each row describes one directed dyadic relationship.#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param add Additional lavaan syntax pasted at the end of the generated model. Can contain, for example, user specified error correlations.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param syntax In that variable the user can directly provide a lavaan model syntax. Then no automatical model syntax is generated; it is important that the variable nakes in the formula#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments passed to the \code{sem} function of \code{lavaan}#
#' @param means Should the structured means of the SRM factors be calculated?#
#
## OLD PARAMETERS, NOT CURRENTLY USED#
# @param err Defines the type of correlations between error terms. err = 1: Correlate same items BETWEEN ALL RATERS (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000); err = 2: Correlate same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
# @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196-213. doi:10.1177/1088868309353414#
#
fSRM <-#
function(formula=NULL, data, fe=TRUE, add="", means=FALSE, IGSIM=list(), add.variable=c(), selfmode="cor", syntax="", ...) {#
	library(lavaan)#
	library(reshape2)#
	library(plyr)#
	dots <- list(...)#
	# TODO: Re-introduce self-ratings? Preliminarily, fix it to FALSE#
	self <- FALSE#
	# save the function call for use in refitting#
	call <- match.call(expand.dots = TRUE)#
	# Parse the formula#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	# Retrieve the variable names from the formula#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	# Restructure data format from long to wide#
	fam0 <- list()#
	for (v in c(var.id, add.variable)) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id, add.variable)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	# remove all-NA columns#
	NAcol <- which(apply(fam, 2, function(x) sum(is.na(x))) == nrow(fam))#
	if(length(NAcol)>0)	{fam <- fam[, -NAcol]}#
	fam <- na.omit(fam)#
	included <- fam[, group.id]#
	roles <- sort(unique(data[, actor.id]))#
	# Do some sanity checks#
	if (length(roles) == 3 & fe == TRUE & means == FALSE) {warning("Data set with 3-member-groups detected - model probably is not identified. Maybe you should remove the family effect (fe = FALSE) or some of the reciprocities?")}#
	if (!identical(sort(unique(data[, actor.id])), sort(unique(data[, partner.id])))) {#
		warning("Actor.id and Partner.id have different factor levels; results might be wrong!")#
	}#
	if (means == TRUE && fe == FALSE) {#
		warning("If mean structure for a three person family is requested, the family effect is allowed, but its variance constrained to zero.")#
		fe <- TRUE#
	}#
	# if no syntax is directly provided:#
	if (syntax == "") {#
		syntax0 <- buildSRMSyntaxLatent(roles, var.id, fe=fe, err="default", IGSIM=IGSIM, means=means, self=self, add.variable=add.variable, selfmode=selfmode)#
		syntax <- paste(syntax0, add, sep="\n")#
	} else {#
		print("Model syntax is directly specified; skipping buildfSRMSyntax")#
	}#
	m <- lavaan(#
			model		= syntax, #
			data		= fam,#
			std.ov		= FALSE,#
			orthogonal	= TRUE,#
			fixed.x 	= FALSE,#
			int.ov.free	= TRUE,#
			int.lv.free = FALSE,#
			auto.fix.first = FALSE,#
			auto.fix.single = TRUE,#
			auto.var 	= TRUE,#
			auto.cov.lv.x = TRUE,#
			auto.cov.y 	= TRUE, ...)#
	res <- list(#
		fit		= m,#
		SS		= standardizedSolution(m, type="std.all"),#
		syntax	= syntax,#
		roles	= roles,#
		actor.id 	= actor.id,#
		partner.id 	= partner.id,#
		group.id 	= group.id,#
		var.id	= var.id,#
		fe		= fe,#
		means	= means,#
		IGSIM	= IGSIM,#
		self	= self,#
		selfmode	= selfmode,#
		call	= call,#
		data	= fam)#
	attr(res, "class") <- "fSRM"#
	return(res)	#
}#
# rerun a fSRM model with new parameters specified#
update.fSRM <- function(x, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# predicts new cases#
# TODO: @Yves: Allow single row data frames, omit unnecessary sanity checks#
predict.fSRM <- function(x, newdata, ...) {#
	# TODO: This snippet is also in fSRM function --> refactor#
	# Restructure data format from long to wide#
	fam0 <- list()#
	for (v in c(x$var.id, x$add.variable)) {#
		fam0[[v]] <- dcast(newdata[, c(x$var.id, x$actor.id, x$partner.id, x$group.id, x$add.variable)], formula(paste(x$group.id, "~", x$actor.id, "+", x$partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
#
	fam <- merge.rec(fam0, by=x$group.id)#
	print(str(x$data))#
	print(str(fam))#
	predict(x$fit, newdata=fam)#
}
