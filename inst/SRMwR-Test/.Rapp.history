setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
load("FIRM00.RData")
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
library(lavaan)#
library(reshape2)#
#
RRdat2 <- merge(dat00[, c("pid", "sex", "age", "role")], RRdat, by="pid")#
TID <- dat00[, c("pid", "role")]#
colnames(TID)[1] <- "tid"#
RRdat4 <- merge(RRdat2, TID, by="tid", suffixes=c(".p", ".t"))#
RRdat4[RRdat4$pid == RRdat4$tid, grepl("RR", colnames(RRdat4))] <- NA#
RRdat4 <- RRdat4[order(RRdat4$pid), ]#
#
# Motivratings (3 Items) mitteln#
RRdat4$RR_POW <- cronbach(RRdat4[, c("RR_UMS1_2", "RR_UMS2_1", "RR_UMS2_3")])#
RRdat4$RR_ACH <- cronbach(RRdat4[, c("RR_UMS2_0", "RR_UMS2_5", "RR_UMS2_7")])#
RRdat4$RR_AFF <- cronbach(RRdat4[, c("RR_UMS1_1", "RR_UMS1_5", "RR_UMS2_4")])#
RRdat4$RR_INT <- cronbach(RRdat4[, c("RR_UMS1_3", "RR_UMS2_2", "RR_UMS2_6")])#
RRdat4$RR_FEAR <- cronbach(RRdat4[, c("RR_UMS1_0", "RR_UMS1_4", "RR_UMS1_6")])#
buildSRMSyntax <- function(role, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list()) {#
#
	pasteNS <- function(x, y, sep="_") {#
		res <- c()#
		for (i in x) {#
			for (j in y) {#
				if (i != j) {res <- c(res, paste(i,j, sep=sep))}#
			}#
		}#
		return(res)#
	}#
#
	R.p <- role#
#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("1*", pasteNS(R.p, R.p), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ 1*", pasteNS(p, t), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, paste(R.p[p], R.p[t], sep="_"), " ~~ ", paste(R.p[t], R.p[p], sep="_"), "\n", sep="")#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- paste(FE, PE, TE, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}#
RR.roles <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "+", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be dewfined in the formula (after the | operator).")#
	}#
	fam <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=var.id)#
	R.p <- sort(unique(data[, actor.id]))#
	model <- buildSRMSyntax(R.p, ...)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, roles=R.p)#
	attr(res, "class") <- "RR.role.uni"#
	return(res)#
}#
# calculate percentages#
percTable <- function(x) {#
	eff <- parameterEstimates(x$model)#
	eff$f <- paste(eff$lhs, eff$op, eff$rhs)#
	res <- matrix(NA, ncol=5, nrow=nrow(eff[eff$lhs=="FE" & eff$op == "=~", ]))#
	colnames(res) <- c("Family", "Perceiver Effect", "Target Effect", "Relationship Effect", "SUM")#
	rownames(res) <- rep("", nrow(res))#
	count <- 1#
	for (p in 1:length(x$roles)) {#
		for (t in 1:length(x$roles)) {#
			if (x$roles[p] != x$roles[t]) {#
				res[count, 1:4] <- c(#
					eff[eff$f == "FE ~~ FE", "est"],#
					eff[eff$f == paste("PE", x$roles[p], " ~~ ", "PE", x$roles[p], sep=""), "est"],#
					eff[eff$f == paste("TE", x$roles[t], " ~~ ", "TE", x$roles[t], sep=""), "est"],#
					eff[eff$f == paste(paste(x$roles[p], x$roles[t], sep="_"), "~~", paste(x$roles[p], x$roles[t], sep="_")), "est"])#
				res[count, 5] <- sum(res[count, 1:4])#
				rownames(res)[count] <- paste(x$roles[p], x$roles[t], sep="_")#
				count <- count + 1#
			}#
		}#
	}#
#
	res2 <- round((res[, 1:4] / res[, 5])*100)#
	res2 <- data.frame(addmargins(res2, margin=1, FUN=mean))#
	return(list(raw=res, stand=res2))#
}#
print.RR.role.uni <- function(x, ...) {#
	## Das Modell muss bei 4 Personen: 31 freie parameter und 47 df haben!#
	cat(paste("SRM with roles (", paste(x$roles, collapse=", "), sep=""), ") :\n----------------\n")#
	cat("\nModel summary:\n----------------\n")#
	show(x$model)#
	cat("\nModel Fit:\n----------------\n")#
	FIT <- fitmeasures(x$model)#
	cat(paste("Chi2 (df=", FIT["df"], ") = ", round(FIT["chisq"], 3), ", p = ", round(FIT["pvalue"], 3), "\n", sep=""))#
	cat(paste("CFI = ", round(FIT["cfi"], 3), "\n", sep=""))#
	cat(paste("RMSEA = ", round(FIT["rmsea"], 3), " [", round(FIT["rmsea.ci.lower"], 3), ";", round(FIT["rmsea.ci.upper"], 3), "]", "; Test of close fit: p(RMSEA == .05) = ", round(FIT["rmsea.pvalue"], 3), "\n", sep=""))#
	cat("\n\nRelative variance decomposition:\n----------------\n")#
	print(round(percTable(x)$stand))#
	cat("\n\nGeneralized reciprocity (actor-partner-effect covariances):\n----------------\n")#
	print(parameterEstimates(s1$model)[37:40,])#
	cat("\n\nDyadic reciprocity (relationship-effect covariances):\n----------------\n")#
	print(parameterEstimates(s1$model)[41:46,])#
}#
(s1 <- RR.roles(RR_POW ~ role.p*role.t | gid, RRdat4))
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
library(lavaan)#
library(reshape2)#
#
RRdat2 <- merge(dat00[, c("pid", "sex", "age", "role")], RRdat, by="pid")#
TID <- dat00[, c("pid", "role")]#
colnames(TID)[1] <- "tid"#
RRdat4 <- merge(RRdat2, TID, by="tid", suffixes=c(".p", ".t"))#
RRdat4[RRdat4$pid == RRdat4$tid, grepl("RR", colnames(RRdat4))] <- NA#
RRdat4 <- RRdat4[order(RRdat4$pid), ]#
#
# Motivratings (3 Items) mitteln#
RRdat4$RR_POW <- cronbach(RRdat4[, c("RR_UMS1_2", "RR_UMS2_1", "RR_UMS2_3")])#
RRdat4$RR_ACH <- cronbach(RRdat4[, c("RR_UMS2_0", "RR_UMS2_5", "RR_UMS2_7")])#
RRdat4$RR_AFF <- cronbach(RRdat4[, c("RR_UMS1_1", "RR_UMS1_5", "RR_UMS2_4")])#
RRdat4$RR_INT <- cronbach(RRdat4[, c("RR_UMS1_3", "RR_UMS2_2", "RR_UMS2_6")])#
RRdat4$RR_FEAR <- cronbach(RRdat4[, c("RR_UMS1_0", "RR_UMS1_4", "RR_UMS1_6")])#
merge.rec <- function(.list, ...){#
	if(length(.list)==1) return(.list[[1]])#
	Recall(c(list(merge(.list[[1]], .list[[2]], ...)), .list[-(1:2)]), ...)#
}#
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
#
	# Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		for (p in R.p) {#
			M <- pasteNS(p, R.p, v)#
			for (m2 in 1:length(M)) {#
				for (m3 in 1:length(M)) {#
					if (m2 < m3) {#
						ERR2 <- paste(ERR2, M[m2], " ~~ MF", count, "*", M[m3], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR2, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}#
RR.roles.latent <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, roles=R.p, var.id=var.id)#
	attr(res, "class") <- "RR.role.latent"#
	return(res)#
}#
#
x <- RR.roles(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat3)#
# calculate percentages#
percTable.latent <- function(x) {#
	eff <- parameterEstimates(x$model)#
	eff$f <- paste(eff$lhs, eff$op, eff$rhs)#
	res <- matrix(NA, ncol=6, nrow=length(x$roles)*(length(x$roles)-1))#
	colnames(res) <- c("Family", "Perceiver Effect", "Target Effect", "Relationship Effect", "Error", "SUM")#
	rownames(res) <- rep("", nrow(res))#
	count <- 1#
	for (p in 1:length(x$roles)) {#
		for (t in 1:length(x$roles)) {#
			if (x$roles[p] != x$roles[t]) {#
				#print(paste(p, t))#
				res[count, 1:4] <- c(#
					eff[eff$f == "FE ~~ FE", "est"],#
					eff[eff$f == paste("PE", x$roles[p], " ~~ ", "PE", x$roles[p], sep=""), "est"],#
					eff[eff$f == paste("TE", x$roles[t], " ~~ ", "TE", x$roles[t], sep=""), "est"],#
					eff[eff$f == paste(paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), sep=""), "~~", paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), sep="")), "est"])#
					# error in all indicators#
					err <- c()#
					for (v in x$var.id) {#
						err <- c(err, eff[eff$f == paste(paste(x$roles[p], x$roles[t], v, sep="_"), "~~", paste(x$roles[p], x$roles[t], v, sep="_")), "est"])#
					}#
					res[count, 5] <- sum(err)#
				res[count, 6] <- sum(res[count, 1:5])#
				rownames(res)[count] <- paste(x$roles[p], x$roles[t], sep="_")#
				count <- count + 1#
			}#
		}#
	}#
#
	res2 <- round((res[, 1:5] / res[, 6])*100)#
	res2 <- data.frame(addmargins(res2, margin=1, FUN=mean))#
	res2$explained <- 100-res2$Error#
	return(list(raw=res, stand=res2))#
}#
print.RR.role.latent <- function(x, ...) {#
	## Das Modell muss bei 4 Personen: 31 freie parameter und 47 df haben!#
	cat(paste("SRM with roles (latent) (Roles: ", paste(x$roles, collapse=", "), sep=""), "; DVs = ", x$var.id, ") :\n----------------\n")#
	cat("\nModel summary:\n----------------\n")#
	show(x$model)#
	cat("\nModel Fit:\n----------------\n")#
	FIT <- fitmeasures(x$model)#
	cat(paste("Chi2 (df=", FIT["df"], ") = ", round(FIT["chisq"], 3), ", p = ", round(FIT["pvalue"], 3), "\n", sep=""))#
	cat(paste("CFI = ", round(FIT["cfi"], 3), "\n", sep=""))#
	cat(paste("RMSEA = ", round(FIT["rmsea"], 3), " [", round(FIT["rmsea.ci.lower"], 3), ";", round(FIT["rmsea.ci.upper"], 3), "]", "; Test of close fit: p(RMSEA == .05) = ", round(FIT["rmsea.pvalue"], 3), "\n", sep=""))#
	cat("\n\nRelative variance decomposition:\n----------------\n")#
	print(round(percTable.latent(x)$stand))#
	eff <- parameterEstimates(x$model)#
	eff$f <- paste(eff$lhs, eff$op, eff$rhs)	#
	cat("\n\nGeneralized reciprocity (actor-partner-effect covariances):\n----------------\n")#
	sel <- c()#
	for (t in x$roles) {sel <- c(sel, paste("PE", t, " ~~ ", "TE", t, sep=""))}#
	print(eff[eff$f %in% sel , c("f", "est", "se", "z", "pvalue", "ci.lower","ci.upper")])#
	cat("\n\nDyadic reciprocity (relationship-effect covariances):\n----------------\n")#
	sel <- c()#
	for (p in 1:length(x$roles)) {#
		for (t in 1:length(x$roles)) {#
			if ((p < t) & (x$roles[p] != x$roles[t])) {#
				sel <- c(sel, paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), " ~~ ", "RE", substr(x$roles[t], 1, 1), substr(x$roles[p], 1, 1), sep=""))#
			}#
		}#
	}#
	print(eff[eff$f %in% sel , c("f", "est", "se", "z", "pvalue", "ci.lower","ci.upper")])#
}#
# POW#
(x <- RR.roles.latent(RR_UMS1_2/RR_UMS2_1/RR_UMS2_3 ~ role.p*role.t | gid, RRdat4))#
percTable.latent(x)$raw
summary(x$model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
parTable(x$model)
?parTable
vcov(x$model)
str(vcov(x$model))
parameterTable(x$model)
inspect(x$model)
str(vcov(x$model))
str(fitted(x$model))
fitted(x$model)
resid(x$model)
summary(x$model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
#
	# Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		for (p in R.p) {#
			M <- pasteNS(p, R.p, v)#
			for (m2 in 1:length(M)) {#
				for (m3 in 1:length(M)) {#
					if (m2 < m3) {#
						ERR2 <- paste(ERR2, "err", count, " =~ ", M[m2], "\n", sep="")#
						count <- count + 1#
						ERR2 <- paste(ERR2, "err", count, " =~ ", M[m3], "\n", sep="")#
						count <- count + 1#
						ERR2 <- paste(ERR2, err, count-2, " ~~ ", err, count-1, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR2, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}#
RR.roles.latent <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, roles=R.p, var.id=var.id)#
	attr(res, "class") <- "RR.role.latent"#
	return(res)#
}#
#
x <- RR.roles(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat3)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
x <- RR.roles(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat4)
head(RRdat4)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
x <- RR.roles(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat4)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
x <- RR.roles.latent(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat4)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
formula <- RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
data-RRdat4
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
data <- RRdat4
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		for (p in R.p) {#
			M <- pasteNS(p, R.p, v)#
			for (m2 in 1:length(M)) {#
				for (m3 in 1:length(M)) {#
					if (m2 < m3) {#
						ERR2 <- paste(ERR2, "err", count, " =~ ", M[m2], "\n", sep="")#
						count <- count + 1#
						ERR2 <- paste(ERR2, "err", count, " =~ ", M[m3], "\n", sep="")#
						count <- count + 1#
						ERR2 <- paste(ERR2, "err", count-2, " ~~ ", "err", count-1, "\n", sep="")#
					}#
				}#
			}#
		}#
	}
ERR2
cat(ERR2)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	# define error terms#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				ERR2 <- paste(ERR2, "err", p, t, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}
cat(ERR12)
cat(ERR2)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	# define error terms#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR2 <- paste(ERR2, "err", p, t, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}
cat(ERR2)
x
x0 <- x
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
ERR2 <- "# Method covariance: Correlations among error terms:\n"
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}
cat(ERR2)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
ERR0 <- "# Error terms:\n"#
	count <- 1#
	# define error terms#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}
cat(ERR0)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}
cat(ERR2)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}
cat(ERR2)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
#
	# Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	ERR0 <- "# Error terms:\n"#
	count <- 1#
	# define error terms#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}#
	# define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR0, ERR2, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
(x <- RR.roles.latent(RR_UMS1_2/RR_UMS2_1/RR_UMS2_3 ~ role.p*role.t | gid, RRdat4))
summary(x0$model)
summary(x$model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# define error terms#
	ERR0 <- "# Error terms:\n"#
	count <- 1#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR1 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR1 <- paste(ERR1, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
	# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	# define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR0, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
x.ERR0 <- RR.roles.latent(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat4)
summary(x.ERR0$model)
?sem
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise", auto.fix.single)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise", auto.fix.single)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
m <- lavaan(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise", auto.fix.single=TRUE)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise", auto.fix.single=FALSE)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
formula <- anx1/anx2 ~ pid*tid | id2#
data <- dat3#
#
s1 <- RR.roles.latent(value ~ pid*tid | id2, dat2)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
library(foreign)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
Koeffizienten und model fits passen alle!#
## Es fehlen noch die Korrelationen (generalized and dyadic covariances)#
## --> wie kommt man von den Kovarianzen zu den Korrelationen?#
#
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
formula <- anx1/anx2 ~ pid*tid | id2#
data <- dat3#
#
s1 <- RR.roles.latent(value ~ pid*tid | id2, dat2)
s1
summary(s1$model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
merge.rec <- function(.list, ...){#
	if(length(.list)==1) return(.list[[1]])#
	Recall(c(list(merge(.list[[1]], .list[[2]], ...)), .list[-(1:2)]), ...)#
}#
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# define error terms#
	ERR0 <- "# Error terms:\n"#
	count <- 1#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR1 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR1 <- paste(ERR1, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
	# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	# define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR1, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}#
RR.roles.latent <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, roles=R.p, var.id=var.id)#
	attr(res, "class") <- "RR.role.latent"#
	return(res)#
}#
#
formula <- RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid#
data <- RRdat4#
x.ERR0 <- RR.roles.latent(RR_emoSupp1/RR_emoSupp2_2 ~ role.p*role.t | gid, RRdat4)#
# calculate percentages#
percTable.latent <- function(x) {#
	eff <- parameterEstimates(x$model)#
	eff$f <- paste(eff$lhs, eff$op, eff$rhs)#
	res <- matrix(NA, ncol=6, nrow=length(x$roles)*(length(x$roles)-1))#
	colnames(res) <- c("Family", "Perceiver Effect", "Target Effect", "Relationship Effect", "Error", "SUM")#
	rownames(res) <- rep("", nrow(res))#
	count <- 1#
	for (p in 1:length(x$roles)) {#
		for (t in 1:length(x$roles)) {#
			if (x$roles[p] != x$roles[t]) {#
				#print(paste(p, t))#
				res[count, 1:4] <- c(#
					eff[eff$f == "FE ~~ FE", "est"],#
					eff[eff$f == paste("PE", x$roles[p], " ~~ ", "PE", x$roles[p], sep=""), "est"],#
					eff[eff$f == paste("TE", x$roles[t], " ~~ ", "TE", x$roles[t], sep=""), "est"],#
					eff[eff$f == paste(paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), sep=""), "~~", paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), sep="")), "est"])#
					# error in all indicators#
					err <- c()#
					for (v in x$var.id) {#
						err <- c(err, eff[eff$f == paste(paste(x$roles[p], x$roles[t], v, sep="_"), "~~", paste(x$roles[p], x$roles[t], v, sep="_")), "est"])#
					}#
					res[count, 5] <- sum(err)#
				res[count, 6] <- sum(res[count, 1:5])#
				rownames(res)[count] <- paste(x$roles[p], x$roles[t], sep="_")#
				count <- count + 1#
			}#
		}#
	}#
#
	res2 <- round((res[, 1:5] / res[, 6])*100)#
	res2 <- data.frame(addmargins(res2, margin=1, FUN=mean))#
	res2$explained <- 100-res2$Error#
	return(list(raw=res, stand=res2))#
}#
print.RR.role.latent <- function(x, ...) {#
	## Das Modell muss bei 4 Personen: 31 freie parameter und 47 df haben!#
	cat(paste("SRM with roles (latent) (Roles: ", paste(x$roles, collapse=", "), sep=""), "; DVs = ", x$var.id, ") :\n----------------\n")#
	cat("\nModel summary:\n----------------\n")#
	show(x$model)#
	cat("\nModel Fit:\n----------------\n")#
	FIT <- fitmeasures(x$model)#
	cat(paste("Chi2 (df=", FIT["df"], ") = ", round(FIT["chisq"], 3), ", p = ", round(FIT["pvalue"], 3), "\n", sep=""))#
	cat(paste("CFI = ", round(FIT["cfi"], 3), "\n", sep=""))#
	cat(paste("RMSEA = ", round(FIT["rmsea"], 3), " [", round(FIT["rmsea.ci.lower"], 3), ";", round(FIT["rmsea.ci.upper"], 3), "]", "; Test of close fit: p(RMSEA == .05) = ", round(FIT["rmsea.pvalue"], 3), "\n", sep=""))#
	cat("\n\nRelative variance decomposition:\n----------------\n")#
	print(round(percTable.latent(x)$stand))#
	eff <- parameterEstimates(x$model)#
	eff$f <- paste(eff$lhs, eff$op, eff$rhs)	#
	cat("\n\nGeneralized reciprocity (actor-partner-effect covariances):\n----------------\n")#
	sel <- c()#
	for (t in x$roles) {sel <- c(sel, paste("PE", t, " ~~ ", "TE", t, sep=""))}#
	print(eff[eff$f %in% sel , c("f", "est", "se", "z", "pvalue", "ci.lower","ci.upper")])#
	cat("\n\nDyadic reciprocity (relationship-effect covariances):\n----------------\n")#
	sel <- c()#
	for (p in 1:length(x$roles)) {#
		for (t in 1:length(x$roles)) {#
			if ((p < t) & (x$roles[p] != x$roles[t])) {#
				sel <- c(sel, paste("RE", substr(x$roles[p], 1, 1), substr(x$roles[t], 1, 1), " ~~ ", "RE", substr(x$roles[t], 1, 1), substr(x$roles[p], 1, 1), sep=""))#
			}#
		}#
	}#
	print(eff[eff$f %in% sel , c("f", "est", "se", "z", "pvalue", "ci.lower","ci.upper")])#
}
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
Koeffizienten und model fits passen alle!#
## Es fehlen noch die Korrelationen (generalized and dyadic covariances)#
## --> wie kommt man von den Kovarianzen zu den Korrelationen?#
#
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
formula <- anx1/anx2 ~ pid*tid | id2#
data <- dat3#
#
s1 <- RR.roles.latent(value ~ pid*tid | id2, dat2)
dat3
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat2)
head(data)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat2)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat3)
s1
summary(s1$model)
head(dat)
cat(model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("FE*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# define error terms#
	ERR0 <- "# Error terms:\n"#
	count <- 1#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR1 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR1 <- paste(ERR1, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
	# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	# define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR1, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}
cat(s1$model)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
RR.roles.latent <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, syntax =model, roles=R.p, var.id=var.id)#
	attr(res, "class") <- "RR.role.latent"#
	return(res)#
}
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat3)
cat(s1$syntax)
vcov(s1)
vcov(s1$model)
fitted(s1$model)
cov(dat)
fitted(s1$model)
round(cov(dat), 3)
diag(fitted(s1$model))
fitted(s1$model)
round(cov(dat), 3)
resid(s1$model)
s1
summary(s1$model)
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat3)
cat(s1$syntax)
setwd('/Users/Felix/Documents/LMU/Research/1 - In Arbeit/FIRM/R')
buildSRMSyntaxLatent <- function(role, var.id, w.p = rep("NA", 4), w.t = rep("NA", 4), IGSIM = list(), fe=TRUE) {#
#
	pasteNS <- function(x, y, v="", sep="_") {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	R.p <- role#
	# Family effect#
	FE <- paste("# Family effect:\nFE =~ ", paste("1*", pasteNS(R.p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")#
#
	# Partner effects#
	PE <- "# Perceiver effects:\n"#
	for (p in R.p) {PE <- paste(PE, "PE", p, " =~ ", paste("1*", pasteNS(p, R.p, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Target effects#
	TE <- "# Target effect:\n"#
	for (t in R.p) {TE <- paste(TE, "TE", t, " =~ ", paste("1*", pasteNS(R.p, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effect:\n"#
	for (p in R.p) {#
		for (t in R.p) {#
			if (p != t) {RE <- paste(RE, "RE", substr(p, 1, 1), substr(t, 1, 1), " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in R.p) {GR <- paste(GR, "PE", p, " ~~ TE", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(R.p)) {#
		for (t in 1:length(R.p)) {#
			if ((p < t) & (R.p[p] != R.p[t])) {#
				DR <- paste(DR, "RE", substr(R.p[p], 1, 1), substr(R.p[t], 1, 1), " ~~ ", "RE", substr(R.p[t], 1, 1), substr(R.p[p], 1, 1), "\n", sep="")#
			}#
		}#
	}#
	# define error terms#
	ERR0 <- "# Error terms:\n"#
	count <- 1#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t in 1:length(R.p)) {#
				if (p != t)	ERR0 <- paste(ERR0, "err", p, t, v, " =~ ", pasteNS(R.p[p], R.p[t], var.id[v]), "\n", sep="")#
			}#
		}#
	}#
	# method correlations: The same items are allowed to correlate#
	# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
	ERR1 <- "# Method covariance: Correlations among error terms:\n"#
	count <- 1#
	for (v in var.id) {#
		M <- pasteNS(R.p, R.p, v)#
		for (m1 in 1:length(M)) {#
			for (m2 in 1:length(M)) {#
				if ((m1 < m2) & (M[m1] != M[m2])) {#
					ERR1 <- paste(ERR1, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
					count <- count + 1#
				}#
			}#
		}#
	}#
	# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
	# define correlations between error terms#
	ERR2 <- "# Method covariance: Correlations among error terms:\n"#
	for (v in 1:length(var.id)) {#
		for (p in 1:length(R.p)) {#
			for (t1 in 1:length(R.p)) {#
				for (t2 in 1:length(R.p)) {#
					if (p != t1 & p != t2 & t1 < t2) {#
						ERR2 <- paste(ERR2, "err", p, t1, v, " ~~ ", "err", p, t2, v, "\n", sep="")#
					}#
				}#
			}#
		}#
	}#
#
	# equality constraints#
	count <- 1#
	EQ <- "# Equality constraints\n"#
	for (p in R.p) {#
		EQ <- paste(EQ, "PE", p, " ~~ ", w.p[count], "*PE", p, "\n", sep="")#
		count <- count + 1#
	}#
	count <- 1#
	for (t in R.p) {#
		EQ <- paste(EQ, "TE", t, " ~~ ", w.t[count], "*TE", t, "\n", sep="")#
		count <- count + 1#
	}#
	# intergenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intergenerational similarity:\n"#
		for (i in IGSIM) {#
			igsim <- paste(igsim, "PE", i[1], " ~~ PE", i[2], "\n", sep="")#
			igsim <- paste(igsim, "TE", i[1], " ~~ TE", i[2], "\n", sep="")#
		}#
	}#
#
	SRM <- ""#
	if (fe==TRUE) SRM <- FE#
	SRM <- paste(SRM, PE, TE, RE, ERR1, GR, DR, EQ, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	return(SRM)#
}#
RR.roles.latent <- function(formula, data, ...) {#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	fam0 <- list()#
	for (v in var.id) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	R.p <- sort(unique(data[, actor.id]))#
	#model <- buildSRMSyntaxLatent(R.p, var.id, ...)#
	model <- buildSRMSyntaxLatent(R.p, var.id)#
	m <- sem(model=model, data=fam, std.ov=FALSE, estimator="ML", orthogonal=TRUE, missing="listwise")#
	res <- list(model=m, syntax =model, roles=R.p, var.id=var.id)#
	attr(res, "class") <- "RR.role.latent"#
	return(res)#
}
setwd('/Users/Felix/Documents/R/Funktionen/SRMwR-Test')
s1 <- RR.roles.latent(anx1/anx2 ~ pid*tid | id2, dat3)
cat(s1$syntax)
summary(s1$model)
