options(error=recover)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)
ls()
str(fam)
cat(model2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1) {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1) {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)
s1
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
summary(s1$res)
parameterEstimates(s1$res)
s1$model
cat(s1$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Run a Social Relations Model with roles ("Family SRM")#
#' @aliases add#
#'#
#' @description#
#' Run a Social Relations Model with roles ("Family SRM")#
#'#
#' @details#
#' A model can be rerun with additional syntax using the \code{add} function:#
#' \code{s1 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2)}#
#' \code{s2 <- add(s1, "Ac ~~ Pm")}#
#'#
#' @export#
#' @param formula A formula that defines the variable names. Should be in one of following formats: (1) Single manifest dependent variable: DV ~ actor.id * partner.id | group.id, (2) Multiple indicators for dependent variable: DV1/DV2/DV3 ~ actor.id * parter.id | group.id.#
#' @param data A data frame with all variables defined by \code{formula}. Must be in long format where each row describes one directed dyadic relationship.#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param add Additional lavaan syntax pasted at the end of the generated model. Can contain, for example, user specified error correlations.#
#' @param err Defines the type of correlations between error terms. err = 1: Correlate same items BETWEEN ALL RATERS (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000); err = 2: Correlate same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
#' @param reestimate 0 = no reestimation; 1 = negative variances are set to zero --> new estimation; 2 = negative and non-significant variances (with p > min.p) are set to zero --> new estimation#
#' @param min.p Minimum p value for reestimation: variances with a p value > min.p are set to zero (see also parameter \code{reestimate})#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param model In that variable the user can directly provide a lavaan model syntax. Then no automatical model syntax is generated; it is important that the variable nakes in the formula#
#' @param REESTIMATE Internal parameter, do not use.#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments passed to the \code{sem} function of \code{lavaan}#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
#
fSRM <-#
function(formula=NULL, data, fe=TRUE, add="", err="default", means=FALSE, reestimate=0, min.p=.05, IGSIM=list(), self=FALSE, add.variable=c(), selfmode="cor", model="", REESTIMATE=NULL, ...) {#
	library(lavaan)#
	library(reshape2)#
	library(plyr)#
	dots <- list(...)#
	# save the function call for use in refitting; but only if no refititng is done!#
	#if (is.null(dots[["REESTIMATE"]])) {#
	call <- match.call(expand.dots = TRUE)#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	# Retrieve the variable names from the formula#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	# Restructure data format from long to wide#
	fam0 <- list()#
	for (v in c(var.id, add.variable)) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id, add.variable)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	# remove all-NA columns#
	NAcol <- which(apply(fam, 2, function(x) sum(is.na(x))) == nrow(fam))#
	if(length(NAcol)>0)	{fam <- fam[, -NAcol]}#
	fam <- na.omit(fam)#
	included <- fam[, group.id]#
	roles <- sort(unique(data[, actor.id]))#
	# if no model is directly provided:#
	if (model == "") {#
		model <- buildSRMSyntaxLatent(roles, var.id, fe=fe, err=err, IGSIM=IGSIM, means=means, self=self, add.variable=add.variable, selfmode=selfmode)#
		model2 <- paste(model, add, sep="\n")#
	} else {#
		print("Model syntax is directly specified; skipping buildfSRMSyntax")#
		model2 <- model#
	}#
	# reestimation: exchange or add new paths#
	if (!is.null(REESTIMATE)) {#
		model2 <- paste(model2, "\n## Reestimation adjustments:\n")#
		for (r in 1:length(REESTIMATE[[1]])) {#
			if (grepl(REESTIMATE[[1]][r], model2)) {#
				model2 <- gsub(REESTIMATE[[1]][r], REESTIMATE[[2]][r], model2)#
			} else {#
				model2 <- paste(model2, REESTIMATE[[2]][r], "\n")#
			}#
		}#
	}#
	#m <- sem(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, ...)#
	m <- lavaan(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, int.ov.free = TRUE, int.lv.free = FALSE, auto.fix.first = FALSE, auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE, auto.cov.y = TRUE, ...)#
	# compute factor scores. FS = wide format, FS3 = long format#
	FS <- data.frame(predict(m))#
	FS[, group.id] <- included#
	# TODO: seems buggy#
	FS2 <- list()#
	for (r in roles) {#
		FS2[[r]] <- FS[, grepl(r, colnames(FS))]#
		colnames(FS2[[r]]) <- substr(colnames(FS2[[r]]), 1, 1)#
		FS2[[r]][, group.id] <- FS[, group.id]#
	}#
	FS3 <- ldply(FS2, rbind)#
	colnames(FS3)[1] <- "role"#
	res <- list(res=m, model=model2, roles=roles, var.id=var.id, fe=fe, IGSIM=IGSIM, self=self, selfmode=selfmode, scores.wide=FS, scores.long=FS3, call=call, min.p=min.p, data=fam)#
	attr(res, "class") <- "fSRM"#
	# --> now the basic model is estimated#
	## Do a reestimation of negative or non-significant variance components (VCs)#
	if (reestimate > 0) {#
		VC <- varComp(res)[, 1:7]#
		REP <- rbind(getGR(res)[, 1:7], getDR(res)[, 1:7])#
		ALL <- rbind(VC, REP)#
		if (reestimate == 1 & any(VC[, "est"] <= 0)) {#
			VC.sel <- VC[which(VC$est <= 0), ]#
			print(paste("Following variances are < 0 ... reestimating model with these variances set to zero:", paste(VC.sel$f, collapse=", ")))#
			RE <- list(VC.sel$f, gsub(" ~~ ", " ~~ 0*", VC.sel$f))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
		if (reestimate == 2 & (any(ALL$pvalue > min.p)  | any(VC$est <= 0))) {#
			VC.sel <- VC[which(VC$est <= 0 | VC$pvalue > min.p), ]#
			REP.sel <- REP[which(REP$pvalue > min.p), ]#
			ALL.sel <- c(VC.sel$f, REP.sel$f)#
			print(paste("Following variances are < 0 or non-significant, or non-significant covariances... reestimating model with these (co)variances set to zero:", paste(VC.sel$f, collapse=", "), paste(REP.sel$f, collapse=", ")))#
			RE <- list(ALL.sel, gsub(" ~~ ", " ~~ 0*", ALL.sel))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
	}#
	# no reestimation: directly return the result#
	return(res)	#
}#
# rerun a fSRM model with a prespecified model syntax#
update.fSRM <- function(x, model, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(model)) {#
        call$model <- model#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with an additional model syntax#
add <- function(x, add, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(add)) {#
        call$add <- add#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
		print("Extra arguments detected")#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with additional syntax#
# only used internal#
RE.fSRM <- function(x, RE, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(RE)) {#
        call$REESTIMATE <- RE#
		call$reestimate <- 0	# stop reestimation loop#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
summary(s1$res)
dat2
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
paste(style$familyeffect, "~", SM.prefix, style$familyeffect, "*1\n")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
paste(style$familyeffect, "~", SM.prefix, style$familyeffect, "*1\n", sep="")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1) {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)#
s2 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
s1$res
s2$res
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
library(foreign)#
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
s1 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1) {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
s2 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
s2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
library(foreign)#
library(reshape2)#
dat0 <- read.spss("Cook2000.sav", to.data.frame=TRUE)#
#
# create an indicator variable for the family#
dat0$fam <- 1:nrow(dat0)#
#
# convert to long format#
dat <- melt(dat0, id.vars="fam")#
#
# create indicator variables for actor, partner, and measure ##
dat$actor <- substr(dat$variable, 1, 1)#
dat$partner <- substr(dat$variable, 2, 2)#
dat$v <- substr(dat$variable, 3, 6)#
#
# bring both measures back into columns#
dat2 <- dcast(dat, fam + actor + partner ~ v, value.var="value")#
#
## --> now we have the correct data format for the fSRM package:#
## each row is one directed relationship with multiple measures in columns#
head(dat2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
s1 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
s2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s2$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
s2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2, means=TRUE, err="no")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1 & err != "no") {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
s2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2, means=TRUE, err="no")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Run a Social Relations Model with roles ("Family SRM")#
#' @aliases add#
#'#
#' @description#
#' Run a Social Relations Model with roles ("Family SRM")#
#'#
#' @details#
#' A model can be rerun with additional syntax using the \code{add} function:#
#' \code{s1 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2)}#
#' \code{s2 <- add(s1, "Ac ~~ Pm")}#
#'#
#' @export#
#' @param formula A formula that defines the variable names. Should be in one of following formats: (1) Single manifest dependent variable: DV ~ actor.id * partner.id | group.id, (2) Multiple indicators for dependent variable: DV1/DV2/DV3 ~ actor.id * parter.id | group.id.#
#' @param data A data frame with all variables defined by \code{formula}. Must be in long format where each row describes one directed dyadic relationship.#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param add Additional lavaan syntax pasted at the end of the generated model. Can contain, for example, user specified error correlations.#
#' @param err Defines the type of correlations between error terms. err = 1: Correlate same items BETWEEN ALL RATERS (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000); err = 2: Correlate same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
#' @param reestimate 0 = no reestimation; 1 = negative variances are set to zero --> new estimation; 2 = negative and non-significant variances (with p > min.p) are set to zero --> new estimation#
#' @param min.p Minimum p value for reestimation: variances with a p value > min.p are set to zero (see also parameter \code{reestimate})#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param model In that variable the user can directly provide a lavaan model syntax. Then no automatical model syntax is generated; it is important that the variable nakes in the formula#
#' @param REESTIMATE Internal parameter, do not use.#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments passed to the \code{sem} function of \code{lavaan}#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
#
fSRM <-#
function(formula=NULL, data, fe=TRUE, add="", err="default", means=FALSE, reestimate=0, min.p=.05, IGSIM=list(), self=FALSE, add.variable=c(), selfmode="cor", model="", REESTIMATE=NULL, ...) {#
	library(lavaan)#
	library(reshape2)#
	library(plyr)#
	dots <- list(...)#
	# save the function call for use in refitting; but only if no refititng is done!#
	#if (is.null(dots[["REESTIMATE"]])) {#
	call <- match.call(expand.dots = TRUE)#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	# Retrieve the variable names from the formula#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	# Restructure data format from long to wide#
	fam0 <- list()#
	for (v in c(var.id, add.variable)) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id, add.variable)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	# remove all-NA columns#
	NAcol <- which(apply(fam, 2, function(x) sum(is.na(x))) == nrow(fam))#
	if(length(NAcol)>0)	{fam <- fam[, -NAcol]}#
	fam <- na.omit(fam)#
	included <- fam[, group.id]#
	roles <- sort(unique(data[, actor.id]))#
	# if no model is directly provided:#
	if (model == "") {#
		model <- buildSRMSyntaxLatent(roles, var.id, fe=fe, err=err, IGSIM=IGSIM, means=means, self=self, add.variable=add.variable, selfmode=selfmode)#
		model2 <- paste(model, add, sep="\n")#
	} else {#
		print("Model syntax is directly specified; skipping buildfSRMSyntax")#
		model2 <- model#
	}#
	# reestimation: exchange or add new paths#
	if (!is.null(REESTIMATE)) {#
		model2 <- paste(model2, "\n## Reestimation adjustments:\n")#
		for (r in 1:length(REESTIMATE[[1]])) {#
			if (grepl(REESTIMATE[[1]][r], model2)) {#
				model2 <- gsub(REESTIMATE[[1]][r], REESTIMATE[[2]][r], model2)#
			} else {#
				model2 <- paste(model2, REESTIMATE[[2]][r], "\n")#
			}#
		}#
	}#
	#m <- sem(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, ...)#
	m <- lavaan(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, int.ov.free = TRUE, int.lv.free = FALSE, auto.fix.first = FALSE, auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE, auto.cov.y = TRUE, ...)#
	# compute factor scores. FS = wide format, FS3 = long format#
	FS <- data.frame(predict(m))#
	FS[, group.id] <- included#
	# TODO: seems buggy#
	FS2 <- list()#
	for (r in roles) {#
		FS2[[r]] <- FS[, grepl(r, colnames(FS))]#
		colnames(FS2[[r]]) <- substr(colnames(FS2[[r]]), 1, 1)#
		FS2[[r]][, group.id] <- FS[, group.id]#
	}#
	FS3 <- ldply(FS2, rbind)#
	colnames(FS3)[1] <- "role"#
	res <- list(res=m, model=model2, roles=roles, var.id=var.id, fe=fe, IGSIM=IGSIM, self=self, selfmode=selfmode, scores.wide=FS, scores.long=FS3, call=call, min.p=min.p, data=fam)#
	attr(res, "class") <- "fSRM"#
	# --> now the basic model is estimated#
	## Do a reestimation of negative or non-significant variance components (VCs)#
	if (reestimate > 0) {#
		VC <- varComp(res)[, 1:7]#
		REP <- rbind(getGR(res)[, 1:7], getDR(res)[, 1:7])#
		ALL <- rbind(VC, REP)#
		if (reestimate == 1 & any(VC[, "est"] <= 0)) {#
			VC.sel <- VC[which(VC$est <= 0), ]#
			print(paste("Following variances are < 0 ... reestimating model with these variances set to zero:", paste(VC.sel$f, collapse=", ")))#
			RE <- list(VC.sel$f, gsub(" ~~ ", " ~~ 0*", VC.sel$f))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
		if (reestimate == 2 & (any(ALL$pvalue > min.p)  | any(VC$est <= 0))) {#
			VC.sel <- VC[which(VC$est <= 0 | VC$pvalue > min.p), ]#
			REP.sel <- REP[which(REP$pvalue > min.p), ]#
			ALL.sel <- c(VC.sel$f, REP.sel$f)#
			print(paste("Following variances are < 0 or non-significant, or non-significant covariances... reestimating model with these (co)variances set to zero:", paste(VC.sel$f, collapse=", "), paste(REP.sel$f, collapse=", ")))#
			RE <- list(ALL.sel, gsub(" ~~ ", " ~~ 0*", ALL.sel))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
	}#
	# no reestimation: directly return the result#
	return(res)	#
}#
# rerun a fSRM model with a prespecified model syntax#
update.fSRM <- function(x, model, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(model)) {#
        call$model <- model#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with an additional model syntax#
add <- function(x, add, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(add)) {#
        call$add <- add#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
		print("Extra arguments detected")#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with additional syntax#
# only used internal#
RE.fSRM <- function(x, RE, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(RE)) {#
        call$REESTIMATE <- RE#
		call$reestimate <- 0	# stop reestimation loop#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1 & err != "no") {#
		SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)
options(error=recover)
s1 <- fSRM(value ~ pid*tid | id2, dat2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
dat <- read.spss("4person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
#
s1 <- fSRM(value ~ pid*tid | id2, dat2)#
s2 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
str(s2)
s2$scores.wide
head(s2$scores.wide)
colMeans(s2$scores.wide)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE)
colMeans(s1$scores.wide)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2)
colMeans(s1$scores.wide)
?sem
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members and a single indicator (values are identical with Table p. 259 in DDA). Does NOT work for multiple indicators ("initial model-implied matrix (Sigma) is not positive definite").#
# Maybe problem with 3 members and 2 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1 & err != "no") {#
		#SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		#SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	}#
	for (p in roles) {#
		SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
dat0 <- read.spss("Cook2000.sav", to.data.frame=TRUE)#
#
# create an indicator variable for the family#
dat0$fam <- 1:nrow(dat0)#
#
# convert to long format#
dat <- melt(dat0, id.vars="fam")#
#
# create indicator variables for actor, partner, and measure ##
dat$actor <- substr(dat$variable, 1, 1)#
dat$partner <- substr(dat$variable, 2, 2)#
dat$v <- substr(dat$variable, 3, 6)#
#
# bring both measures back into columns#
dat2 <- dcast(dat, fam + actor + partner ~ v, value.var="value")#
#
## --> now we have the correct data format for the fSRM package:#
## each row is one directed relationship with multiple measures in columns#
head(dat2)#
## ======================================================================#
## single indicator#
## =========================================================
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/Cook2000')
s2 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2, means=TRUE)
summary(s2$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
library(foreign)#
dat <- read.spss("3person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat$id2 <- 1:nrow(dat)#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)#
dat3 <- dcast(dat2, id2 + pid + tid ~ v, value.var="value")#
#
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE)
summary(s1$res)
s2$model
cat(s2$model)
cat(s1$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
cat(s2$model)
s1$res
s2$res
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE)#
s2 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
s1$res
s2$res
cat(s2$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2, IGSIM=list(c("m", "f"), c("c", "y")))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
dat <- read.spss("4person.sav", to.data.frame=TRUE)#
#
# convert to long format#
dat2 <- melt(dat, id.vars="id2")#
dat2$pid <- substr(dat2$variable, 1, 1)#
dat2$tid <- substr(dat2$variable, 2, 2)#
dat2$v <- substr(dat2$variable, 3, 6)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(value ~ pid*tid | id2, dat2, IGSIM=list(c("m", "f"), c("c", "y")))
summary(s1$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s2 <- fSRM(value ~ pid*tid | id2, dat2, means=TRUE)
s2$model
cat(s2$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
cat(s4$model)
noc <- "### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
A.f ~~ P.f#
A.m ~~ P.m#
A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
## Compute structured means#
# Define labels for subsequent constraints#
A.f ~ xA.f*1#
A.m ~ xA.m*1#
A.y ~ xA.y*1#
P.f ~ xP.f*1#
P.m ~ xP.m*1#
P.y ~ xP.y*1#
R.f.m ~ xR.f.m*1#
R.f.y ~ xR.f.y*1#
R.m.f ~ xR.m.f*1#
R.m.y ~ xR.m.y*1#
R.y.f ~ xR.y.f*1#
R.y.m ~ xR.y.m*1#
# set means of observed variables to zero#
 f_m_anx1 ~ 0#
f_y_anx1 ~ 0#
m_f_anx1 ~ 0#
m_y_anx1 ~ 0#
y_f_anx1 ~ 0#
y_m_anx1 ~ 0#
f_m_anx2 ~ 0#
f_y_anx2 ~ 0#
m_f_anx2 ~ 0#
m_y_anx2 ~ 0#
y_f_anx2 ~ 0#
y_m_anx2 ~ 0 #
#
# set constraints on means for identifiability#
# xA.f + xA.m + xA.y == 0#
# xP.f + xP.m + xP.y == 0#
# xR.f.m + xR.f.y == 0#
# xR.m.f + xR.m.y == 0#
# xR.y.f + xR.y.m == 0#
# xR.m.f + xR.y.f == 0#
# xR.f.m + xR.y.m == 0#
# xR.f.y + xR.m.y == 0"
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, model=noc)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	if (length(var.id) > 1 & err != "no") {#
		#SM <- paste(SM, "\n\n# set variances of observed variables to zero\n")#
		#SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~~ 0*", pasteNS(roles, roles, var.id), collapse="\n"))#
	}#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	# SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	# SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	# #
	# for (p in roles) {#
	# 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	# }#
	# for (p in roles) {#
	# 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	# }#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s4$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	# for (p in roles) {#
	# 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	# }#
	# for (p in roles) {#
	# 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	# }#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
summary(s4$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
#
	## ======================================================================#
	## Label all variances for easy retrieval#
	## ======================================================================#
	LAB.prefix <- "x"#
	LAB <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		LAB <- paste(LAB, paste(style$familyeffect, " ~ ", LAB.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", LAB.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", LAB.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", LAB.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, LAB, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE)
s1$model
cat(s1$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE)
s1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s1 <- fSRM(anx1 ~ pid*tid | id2, dat3, fe=FALSE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
LAB <- "# Define labels for variances"#
LAB.prefix <- ".int."#
if (fe == TRUE) {#
	LAB <- paste(LAB, paste(style$familyeffect, " ~ ", LAB.prefix, style$familyeffect, "*1\n", sep=""))#
}#
#
for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", LAB.prefix, style$actor, ".", p, "*1\n", sep="")}#
for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", LAB.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
for (p in roles) {#
	for (t in roles) {#
		if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", LAB.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
	}#
}
LAB
cat(LAB)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Label variances for easy retrieval#
## ======================================================================#
#
LAB <- "# Define labels for variances"#
LAB.prefix <- ".int."#
if (fe == TRUE) {#
	LAB <- paste(LAB, paste(style$familyeffect, " ~ ", LAB.prefix, style$familyeffect, "*style$familyeffect\n", sep=""))#
}#
#
for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", LAB.prefix, style$actor, ".", p, "*", style$actor, ".", p, "\n", sep="")}#
# for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", LAB.prefix, style$partner, ".", p, "*1\n", sep="")}#
# #
# for (p in roles) {#
# 	for (t in roles) {#
# 		if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", LAB.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
# 	}#
# }#
# #
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, LAB, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))
cat(s4$model)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=FALSE, means=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
noc <- "### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
A.f ~~ P.f#
A.m ~~ P.m#
A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
## Compute structured means#
# Define labels for subsequent constraints#
A.f ~ xA.f*1#
A.m ~ xA.m*1#
A.y ~ xA.y*1#
P.f ~ xP.f*1#
P.m ~ xP.m*1#
P.y ~ xP.y*1#
R.f.m ~ xR.f.m*1#
R.f.y ~ xR.f.y*1#
R.m.f ~ xR.m.f*1#
R.m.y ~ xR.m.y*1#
R.y.f ~ xR.y.f*1#
R.y.m ~ xR.y.m*1#
# set means of observed variables to zero#
 f_m_anx1 ~ 0#
f_y_anx1 ~ 0#
m_f_anx1 ~ 0#
m_y_anx1 ~ 0#
y_f_anx1 ~ 0#
y_m_anx1 ~ 0#
f_m_anx2 ~ 0#
f_y_anx2 ~ 0#
m_f_anx2 ~ 0#
m_y_anx2 ~ 0#
y_f_anx2 ~ 0#
y_m_anx2 ~ 0 #
#
# set constraints on means for identifiability#
xA.f + xA.m + xA.y == 0#
xP.f + xP.m + xP.y == 0#
xR.f.m + xR.f.y == 0#
xR.m.f + xR.m.y == 0#
xR.y.f + xR.y.m == 0#
xR.m.f + xR.y.f == 0#
# xR.f.m + xR.y.m == 0#
# xR.f.y + xR.m.y == 0"
cat(noc)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Run a Social Relations Model with roles ("Family SRM")#
#' @aliases add#
#'#
#' @description#
#' Run a Social Relations Model with roles ("Family SRM")#
#'#
#' @details#
#' A model can be rerun with additional syntax using the \code{add} function:#
#' \code{s1 <- fSRM(dep1/dep2 ~ actor*partner | fam, dat2)}#
#' \code{s2 <- add(s1, "Ac ~~ Pm")}#
#'#
#' @export#
#' @param formula A formula that defines the variable names. Should be in one of following formats: (1) Single manifest dependent variable: DV ~ actor.id * partner.id | group.id, (2) Multiple indicators for dependent variable: DV1/DV2/DV3 ~ actor.id * parter.id | group.id.#
#' @param data A data frame with all variables defined by \code{formula}. Must be in long format where each row describes one directed dyadic relationship.#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param add Additional lavaan syntax pasted at the end of the generated model. Can contain, for example, user specified error correlations.#
#' @param err Defines the type of correlations between error terms. err = 1: Correlate same items BETWEEN ALL RATERS (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000); err = 2: Correlate same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
#' @param reestimate 0 = no reestimation; 1 = negative variances are set to zero --> new estimation; 2 = negative and non-significant variances (with p > min.p) are set to zero --> new estimation#
#' @param min.p Minimum p value for reestimation: variances with a p value > min.p are set to zero (see also parameter \code{reestimate})#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param model In that variable the user can directly provide a lavaan model syntax. Then no automatical model syntax is generated; it is important that the variable nakes in the formula#
#' @param REESTIMATE Internal parameter, do not use.#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments passed to the \code{sem} function of \code{lavaan}#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
#
fSRM <-#
function(formula=NULL, data, fe=TRUE, add="", err="default", means=FALSE, reestimate=0, min.p=.05, IGSIM=list(), self=FALSE, add.variable=c(), selfmode="cor", model="", REESTIMATE=NULL, ...) {#
	library(lavaan)#
	library(reshape2)#
	library(plyr)#
	dots <- list(...)#
	# save the function call for use in refitting; but only if no refititng is done!#
	#if (is.null(dots[["REESTIMATE"]])) {#
	call <- match.call(expand.dots = TRUE)#
	lhs <- strsplit(gsub(" ","",as.character(formula)[2], fixed=TRUE), "/", fixed=TRUE)[[1]]#
	rhs <- strsplit(gsub(" ","",as.character(formula)[3], fixed=TRUE),"\\*|\\|", perl=TRUE)[[1]]#
	# Retrieve the variable names from the formula#
	var.id <- lhs#
	actor.id <- rhs[1]#
	partner.id <- rhs[2]#
	group.id <- NULL#
	if (length(rhs)>=3) {#
		group.id <- rhs[3]#
	} else {#
		stop("For SRM with roles a group id has to be defined in the formula (after the | operator).")#
	}#
	# Restructure data format from long to wide#
	fam0 <- list()#
	for (v in c(var.id, add.variable)) {#
		fam0[[v]] <- dcast(data[, c(var.id, actor.id, partner.id, group.id, add.variable)], formula(paste(group.id, "~", actor.id, "+", partner.id)), value.var=v)#
		colnames(fam0[[v]])[-1] <- paste(colnames(fam0[[v]])[-1], v, sep="_")#
	}#
	fam <- merge.rec(fam0, by=group.id)#
	# remove all-NA columns#
	NAcol <- which(apply(fam, 2, function(x) sum(is.na(x))) == nrow(fam))#
	if(length(NAcol)>0)	{fam <- fam[, -NAcol]}#
	fam <- na.omit(fam)#
	included <- fam[, group.id]#
	roles <- sort(unique(data[, actor.id]))#
	# if no model is directly provided:#
	if (model == "") {#
		model <- buildSRMSyntaxLatent(roles, var.id, fe=fe, err=err, IGSIM=IGSIM, means=means, self=self, add.variable=add.variable, selfmode=selfmode)#
		model2 <- paste(model, add, sep="\n")#
	} else {#
		print("Model syntax is directly specified; skipping buildfSRMSyntax")#
		model2 <- model#
	}#
	#m <- sem(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, ...)#
	m <- lavaan(model=model2, data=fam, std.ov=FALSE, orthogonal=TRUE, fixed.x=FALSE, int.ov.free = TRUE, int.lv.free = FALSE, auto.fix.first = FALSE, auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE, auto.cov.y = TRUE, ...)#
	# compute factor scores. FS = wide format, FS3 = long format#
	FS <- data.frame(predict(m))#
	FS[, group.id] <- included#
	# TODO: seems buggy#
	FS2 <- list()#
	for (r in roles) {#
		FS2[[r]] <- FS[, grepl(r, colnames(FS))]#
		colnames(FS2[[r]]) <- substr(colnames(FS2[[r]]), 1, 1)#
		FS2[[r]][, group.id] <- FS[, group.id]#
	}#
	FS3 <- ldply(FS2, rbind)#
	colnames(FS3)[1] <- "role"#
	res <- list(res=m, model=model2, roles=roles, var.id=var.id, fe=fe, IGSIM=IGSIM, self=self, selfmode=selfmode, scores.wide=FS, scores.long=FS3, call=call, min.p=min.p, data=fam)#
	attr(res, "class") <- "fSRM"#
	# --> now the basic model is estimated#
	## Do a reestimation of negative or non-significant variance components (VCs)#
	if (reestimate > 0) {#
		VC <- varComp(res)[, 1:7]#
		REP <- rbind(getGR(res)[, 1:7], getDR(res)[, 1:7])#
		ALL <- rbind(VC, REP)#
		if (reestimate == 1 & any(VC[, "est"] <= 0)) {#
			VC.sel <- VC[which(VC$est <= 0), ]#
			print(paste("Following variances are < 0 ... reestimating model with these variances set to zero:", paste(VC.sel$f, collapse=", ")))#
			RE <- list(VC.sel$f, gsub(" ~~ ", " ~~ 0*", VC.sel$f))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
		if (reestimate == 2 & (any(ALL$pvalue > min.p)  | any(VC$est <= 0))) {#
			VC.sel <- VC[which(VC$est <= 0 | VC$pvalue > min.p), ]#
			REP.sel <- REP[which(REP$pvalue > min.p), ]#
			ALL.sel <- c(VC.sel$f, REP.sel$f)#
			print(paste("Following variances are < 0 or non-significant, or non-significant covariances... reestimating model with these (co)variances set to zero:", paste(VC.sel$f, collapse=", "), paste(REP.sel$f, collapse=", ")))#
			RE <- list(ALL.sel, gsub(" ~~ ", " ~~ 0*", ALL.sel))#
			res2 <- RE.fSRM(res, RE)#
			return(res2)#
		}#
	}#
	# no reestimation: directly return the result#
	return(res)	#
}#
# rerun a fSRM model with a prespecified model syntax#
update.fSRM <- function(x, model, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(model)) {#
        call$model <- model#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with an additional model syntax#
add <- function(x, add, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(add)) {#
        call$add <- add#
		call$REESTIMATE <- NULL#
	}#
#
    if(length(extras) > 0) {#
		print("Extra arguments detected")#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}#
# rerun a fSRM model with additional syntax#
# only used internal#
RE.fSRM <- function(x, RE, ..., evaluate=TRUE) {#
	call <- x$call#
    if(is.null(call)) stop("need an fRSM object with call slot")#
#
    extras <- match.call(expand.dots = FALSE)$...#
#
    if(!missing(RE)) {#
        call$REESTIMATE <- RE#
		call$reestimate <- 0	# stop reestimation loop#
	}#
#
    if(length(extras) > 0) {#
        existing <- !is.na(match(names(extras), names(call)))#
        for(a in names(extras)[existing]) call[[a]] <- extras[[a]]#
        if(any(!existing)) {#
            call <- c(as.list(call), extras[!existing])#
            call <- as.call(call)#
        }#
    }#
    if (evaluate) {#
        eval(call, parent.frame())#
    }#
    else call#
}
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
options(error=recover)
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
model
cat(model)
str(data)
options(error=NULL)
noc <- "### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
A.f ~~ P.f#
A.m ~~ P.m#
A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
## Compute structured means#
# Define labels for subsequent constraints#
A.f ~ xA.f*1#
A.m ~ xA.m*1#
A.y ~ xA.y*1#
P.f ~ xP.f*1#
P.m ~ xP.m*1#
P.y ~ xP.y*1#
R.f.m ~ xR.f.m*1#
R.f.y ~ xR.f.y*1#
R.m.f ~ xR.m.f*1#
R.m.y ~ xR.m.y*1#
R.y.f ~ xR.y.f*1#
R.y.m ~ xR.y.m*1#
# set means of observed variables to zero#
 f_m_anx1 ~ 0#
f_y_anx1 ~ 0#
m_f_anx1 ~ 0#
m_y_anx1 ~ 0#
y_f_anx1 ~ 0#
y_m_anx1 ~ 0#
f_m_anx2 ~ 0#
f_y_anx2 ~ 0#
m_f_anx2 ~ 0#
m_y_anx2 ~ 0#
y_f_anx2 ~ 0#
y_m_anx2 ~ 0 #
#
# set constraints on means for identifiability#
xA.f + xA.m + xA.y == 0#
xP.f + xP.m + xP.y == 0#
xR.f.m + xR.f.y == 0#
xR.m.f + xR.m.y == 0#
xR.y.f + xR.y.m == 0#
xR.m.f + xR.y.f == 0#
xR.f.m + xR.y.m == 0#
xR.f.y + xR.m.y == 0"
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
summary(s4b$res)
noc <- "### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
A.f ~~ P.f#
A.m ~~ P.m#
A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
## Compute structured means#
# Define labels for subsequent constraints#
A.f ~ xA.f*1#
A.m ~ xA.m*1#
A.y ~ xA.y*1#
P.f ~ xP.f*1#
P.m ~ xP.m*1#
P.y ~ xP.y*1#
R.f.m ~ xR.f.m*1#
R.f.y ~ xR.f.y*1#
R.m.f ~ xR.m.f*1#
R.m.y ~ xR.m.y*1#
R.y.f ~ xR.y.f*1#
R.y.m ~ xR.y.m*1#
# set means of observed variables to zero#
 f_m_anx1 ~ 0#
f_y_anx1 ~ 0#
m_f_anx1 ~ 0#
m_y_anx1 ~ 0#
y_f_anx1 ~ 0#
y_m_anx1 ~ 0#
f_m_anx2 ~ 0#
f_y_anx2 ~ 0#
m_f_anx2 ~ 0#
m_y_anx2 ~ 0#
y_f_anx2 ~ 0#
y_m_anx2 ~ 0 #
#
# set constraints on means for identifiability#
xA.f + xA.m + xA.y == 0#
xP.f + xP.m + xP.y == 0#
xR.f.m + xR.f.y == 0#
xR.m.f + xR.m.y == 0#
xR.y.f + xR.y.m == 0#
xR.m.f + xR.y.f == 0#
"
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
summary(s4b$res)
head(dat3)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s3 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=TRUE)
summary(s3$res)
cat(s3$model)
parameterEstimates(s3)
parameterEstimates(s3$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Label variances for easy retrieval#
## ======================================================================#
#
LAB <- "# Define labels for variances"#
VAR.prefix <- ".VAR."#
if (fe == TRUE) {#
	LAB <- paste(LAB, paste(style$familyeffect, " ~ ", VAR.prefix, style$familyeffect, "*style$familyeffect\n", sep=""))#
}#
#
for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", VAR.prefix, style$actor, ".", p, "*", style$actor, ".", p, "\n", sep="")}#
for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", VAR.prefix, style$partner, ".", p, "*", style$partner, ".", p, "\n", sep="")}#
#
for (p in roles) {#
	for (t in roles) {#
		if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", VAR.prefix, style$relationship, ".", p, ".", t, "*", style$relationship, ".", p, ".", t, "\n", sep="")}#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, LAB, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Label variances for easy retrieval#
## ======================================================================#
#
LAB <- "# Define labels for variances"#
VAR.prefix <- ".VAR."#
if (fe == TRUE) {#
	LAB <- paste(LAB, paste(style$familyeffect, " ~ ", VAR.prefix, style$familyeffect, "*", style$familyeffect, "\n", sep=""))#
}#
#
for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", VAR.prefix, style$actor, ".", p, "*", style$actor, ".", p, "\n", sep="")}#
for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", VAR.prefix, style$partner, ".", p, "*", style$partner, ".", p, "\n", sep="")}#
#
for (p in roles) {#
	for (t in roles) {#
		if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", VAR.prefix, style$relationship, ".", p, ".", t, "*", style$relationship, ".", p, ".", t, "\n", sep="")}#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, LAB, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
' @title Build lavaan syntax for a Social Relations Model with roles ("Family SRM")#
#'#
#' @description#
#' Build lavaan syntax for a Social Relations Model with roles ("Family SRM"). This function is called by the fSRM function, but can be also #
#'#
#' @details#
#' None.#
#'#
#' @export#
#' @param roles A vector with all role labels.#
#' @param var.id A vector with the variable names of the DV indicators#
#' @param fe Should the family effect be included? Requires at least 4 members per group.#
#' @param err Defines the type of correlations between error terms. err = "no": no error term correlations - this is the required mode for single indicators. err = "within": If multiple indicators are present, correlate same items WITHIN raters (e.g., Branje et al., 2003, Eichelsheim). err = "all": If multiple indicators are present, correlate same items BETWEEN raters (e.g., Dyadic Data Analysis, Kenny, Kashy, & Cook, 2000). err = "default": Set err to "no" for single indicators and to "all" for multiple indicators.#
#' @param IGSIM Define intragenerational similarity correlations. Must be a list where the levels of actor.id and partner.id are combined, e.g.: \code{IGSIM=list(c("m", "f"), c("c", "y"))}. Here "m"other and "f"ather are defined as one generation, and "y"ounger and "o"lder as the other generation.#
#' @param self Should self-ratings be included in the analysis (if present in the data set)?#
#' @param selfmode Defines the style how the selfratings are combined with the latent actor and partner effects. If \code{selfmode="cor"} they are correlated (as in REFERENCE), if \code{selfmode="kq"} the k and q paths are calculated (see Kenny & West, 2010)#
#' @param add.variable Not yet fully implemented: Add external variables to the model syntax.#
#' @param ... Additional arguments (not documented yet)#
#' @param means Should the structured means of the SRM factors be calculated?#
#
#' @references#
#' Kenny, D. A., & West, T. V. (2010). Similarity and Agreement in Self-and Other Perception: A Meta-Analysis. Personality and Social Psychology Review, 14(2), 196–213. doi:10.1177/1088868309353414#
buildSRMSyntaxLatent <-#
function(roles, var.id, self=FALSE, IGSIM = list(), fe=TRUE, err="default", means=FALSE, add.variable=c(), selfmode="cor", ...) {#
	err <- match.arg(err, c("no", "all", "within", "default"))#
	if (err == "default" & length(var.id) == 1) {err <- "no"}#
	if (err == "default" & length(var.id) > 1) {err <- "all"}#
#
	dots <- list(...)#
#
	# helper function: paste two vectors together, but only if elements are not identical#
	pasteNS <- function(x, y, v="", sep="_", self=FALSE) {#
		if (v[1] == "") {#
			res <- c()#
			for (i in x) {#
				for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j, sep=sep))}}#
			}#
			return(res)#
		} else {#
			res <- c()#
			for (k in v) {#
				for (i in x) {#
					for (j in y) {if (i != j | self==TRUE) {res <- c(res, paste(i,j,k, sep=sep))}}#
				}#
			}#
			return(res)#
		}#
	}#
#
	# Family effect#
	FE <- paste("# Family effect:\n", style$familyeffect," =~ ", paste("1*", pasteNS(roles, roles, var.id), sep="", collapse=" + "), sep="")#
	if (self == TRUE) {#
		# self factors (not indicators!) should load on family effect, but with free loadings (D. Kenny, Email from June 15, 2012)#
		for (p in roles) {FE <- paste(FE, " + ", paste(style$self, ".", p, sep="", collapse=" + "), sep="")}#
	}#
	# for (a in add.variable) {#
	# 		for (r in roles) {FE <- paste(FE, " + ", r, "_", r, "_", a, sep="")}#
	# 	}#
	# Actor effects#
	AE <- "\n# Actor effects:\n"#
	for (p in roles) {AE <- paste(AE, style$actor, ".", p, " =~ ", paste("1*", pasteNS(p, roles, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Partner effects#
	PE <- "# Partner effects:\n"#
	for (t in roles) {PE <- paste(PE, style$partner, ".", t, " =~ ", paste("1*", pasteNS(roles, t, var.id), sep="", collapse=" + "), "\n", sep="")}#
#
	# Relationship effects#
	RE <- "# Relationship effects:\n"#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {RE <- paste(RE, style$relationship, ".", p, ".", t, " =~ ", paste("1*", pasteNS(p, t, var.id), collapse=" + "), "\n", sep="")}#
		}#
	}#
#
	# generalized reciprocity#
	GR <- "# Generalized reciprocity:\n"#
	for (p in roles) {GR <- paste(GR, style$actor, ".", p, " ~~ ", style$partner, ".", p, "\n", sep="")}#
#
	# dyadic reciprocity#
	DR <- "# Dyadic reciprocity:\n"#
	for (p in 1:length(roles)) {#
		for (t in 1:length(roles)) {#
			if ((p < t) & (roles[p] != roles[t])) {#
				DR <- paste(DR, style$relationship, ".", roles[p], ".", roles[t], " ~~ ", style$relationship, ".", roles[t], ".", roles[p], "\n", sep="")#
			}#
		}#
	}#
	## ======================================================================#
	## Define method covariance (correlations between errors)#
	## ======================================================================#
	ERR <- ""#
	# single indicator: set error variance to zero#
	if (length(var.id) == 1 | err == "no") {#
		if (err != "no") warning("For one indicator error variances cannot correlate; setting err to 'no'")#
			M <- pasteNS(roles, roles, var.id, self=self)#
			ERR <- paste(paste0(M, " ~~ 0*", M), collapse="\n")#
	} else {#
		ERR <- ""#
	}#
	if (length(var.id) > 1 & err == "all") {#
		# method correlations: The same items are allowed to correlate#
		# ERR1: Correlate same items BETWEEN ALL RATERS (e.g., DDA)#
		ERR <- "# Method covariance: Correlations among all error terms of the same items:\n"#
		count <- 1#
		for (v in var.id) {#
			M <- pasteNS(roles, roles, v, self=self)#
			for (m1 in 1:length(M)) {#
				for (m2 in 1:length(M)) {#
					if ((m1 < m2) & (M[m1] != M[m2])) {#
						ERR <- paste(ERR, M[m1], " ~~ MF", count, "*", M[m2], "\n", sep="")#
						count <- count + 1#
					}#
				}#
			}#
		}#
	}#
	if (length(var.id) > 1 & err == "within") {#
		# ERR2: Correlate for same items WITHIN RATERS (e.g., Branje et al., 2003, Eichelsheim)#
		# define correlations between error terms#
		ERR <- "# Method covariance: Correlations among error terms of one item within actors:\n"#
		count <- 1#
		for (v in 1:length(var.id)) {#
			for (p in 1:length(roles)) {#
				for (t1 in 1:length(roles)) {#
					for (t2 in 1:length(roles)) {#
						if (self == FALSE) {#
							if (p != t1 & p != t2 & t1 < t2) {#
								ERR <- paste(ERR, pasteNS(roles[p], roles[t1], var.id[v]), " ~~ ERR", count, "*", pasteNS(roles[p], roles[t2], var.id[v]), "\n", sep="")#
								count <- count + 1#
							}#
						} else {#
							if (t1 < t2) {#
								ERR <- paste(ERR, paste(roles[p], roles[t1], var.id[v], sep="_"), " ~~ ERR", count, "*", paste(roles[p], roles[t2], var.id[v], sep="_"), "\n", sep="")#
								count <- count + 1#
							}#
						}#
					}#
				}#
			}#
		}#
	}#
	# intragenerational similarity#
	if (length(IGSIM) > 0) {#
		igsim <- "# intragenerational similarity:\n"#
		for (i in 1:length(IGSIM)) {#
			igsim <- paste(igsim, style$actor, ".", IGSIM[[i]][1], " ~~ IGSIMA", i,"*", style$actor, ".", IGSIM[[i]][2], "\n", sep="")#
			igsim <- paste(igsim, style$partner, ".", IGSIM[[i]][1], " ~~ IGSIMP", i,"*", style$partner, ".", IGSIM[[i]][2], "\n", sep="")#
		}#
	}#
	# self-ratings: assumed similarity and self-other agreement#
	# if (self == TRUE) {#
	# 	SELF <- "# Build self-rating factors:\n"#
	# 	for (p in roles) {#
	# 			# TODO: hier mit 1* oder ohne? paste("1*", paste(p, p, var.id, sep="_")#
	# 			SELF <- paste(SELF, "S", p, " =~ ", paste("", paste(p, p, var.id, sep="_"), sep="", collapse=" + "), "\n", sep="")#
	# 	}#
	# 	#
	# 	if (selfmode=="cor") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~~ P", p, "\n", sep="")}#
	# 	}#
	# 	if (selfmode=="kq") {#
	# 		SELF <- paste(SELF, "\n\n# Assumed similarity:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ A", p, "\n", sep="")}#
	# 	#
	# 		SELF <- paste(SELF, "\n\n# Self-other-agreement:\n")#
	# 		for (p in roles) {SELF <- paste(SELF, "S", p, " ~ P", p, "\n", sep="")}#
	# 	}#
	# }#
	# any other variables?#
	addv <- ""#
	# for (a in add.variable) {#
	# 	addv <- "\n\n# Add extra variables to model:\n"#
	# 	for (r in roles) {addv <- paste(addv, a, r, " =~ ", r, "_", r, "_", a, "\n", sep="")}#
	# 	addv <- paste(addv, "# Actor effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ A", r, "\n", sep="")}#
	# 	addv <- paste(addv, "# Partner effect ~~", a, ":\n")#
	# 	for (r in roles) {addv <- paste(addv, a, r, " ~~ P", r, "\n", sep="")}#
	# 	#
	# 	if (self == TRUE) {#
	# 		addv <- paste(addv, "# Self rating ~~", a, ":\n")#
	# 		for (r in roles) {addv <- paste(addv, a, r, " ~~ S", r, "\n", sep="")}#
	# 	}#
	# 	# for (p in roles) {#
	# 	# 	for (t in roles) {#
	# 	# 		if (p != t) {addv <- paste(addv, a, p, " ~~ R", substr(t, 1, 1), substr(p, 1, 1), "\n", sep="")}#
	# 	# 	}#
	# 	# }#
	# 	#
	# }#
## ======================================================================#
## add structured means#
# TODO: Check: should self ratings be included somehow?#
# TODO: Works for 4 members (values are identical with Table p. 259 in DDA).#
# Maybe problem with 3 members and > 1 indicators: very negative Rel-var.#
## ======================================================================#
#
SM <- ""#
if (means==TRUE) {#
	SM.prefix <- "x"#
	SM <- ""#
	SM <- "\n## Compute structured means\n# Define labels for subsequent constraints\n"#
	if (fe == TRUE) {#
		SM <- paste(SM, paste(style$familyeffect, " ~ ", SM.prefix, style$familyeffect, "*1\n", sep=""))#
	}#
#
	for (p in roles) {SM <- paste(SM, style$actor, ".", p, " ~ ", SM.prefix, style$actor, ".", p, "*1\n", sep="")}#
	for (p in roles) {SM <- paste(SM, style$partner, ".", p, " ~ ", SM.prefix, style$partner, ".", p, "*1\n", sep="")}#
#
	for (p in roles) {#
		for (t in roles) {#
			if (p != t) {SM <- paste(SM, style$relationship, ".", p, ".", t, " ~ ", SM.prefix, style$relationship, ".", p, ".", t, "*1\n", sep="")}#
		}#
	}#
	SM <- paste(SM, "\n\n# set means of observed variables to zero\n")#
	SM <- paste(SM, paste(pasteNS(roles, roles, var.id), "~ 0", collapse="\n"))#
	SM <- paste(SM, "\n\n# set constraints on means for identifiability\n")#
	 SM <- paste(SM, paste(paste(SM.prefix, style$actor, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 SM <- paste(SM, paste(paste(SM.prefix, style$partner, ".", roles, sep="", collapse=" + "), "== 0\n"))#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", p, ".", roles[roles != p], sep="", collapse=" + "), "== 0\n"))#
	 }#
	 for (p in roles) {#
	 	SM <- paste(SM, paste(paste(SM.prefix, style$relationship, ".", roles[roles != p], ".", p, sep="", collapse=" + "), "== 0\n"))#
	 }#
}#
## ======================================================================#
## Label variances for easy retrieval#
## ======================================================================#
#
LAB <- "# Define labels for variances\n"#
VAR.prefix <- ".VAR."#
if (fe == TRUE) {#
	LAB <- paste(LAB, paste(style$familyeffect, " ~ ", VAR.prefix, style$familyeffect, "*", style$familyeffect, "\n", sep=""))#
}#
#
for (p in roles) {LAB <- paste(LAB, style$actor, ".", p, " ~ ", VAR.prefix, style$actor, ".", p, "*", style$actor, ".", p, "\n", sep="")}#
for (p in roles) {LAB <- paste(LAB, style$partner, ".", p, " ~ ", VAR.prefix, style$partner, ".", p, "*", style$partner, ".", p, "\n", sep="")}#
#
for (p in roles) {#
	for (t in roles) {#
		if (p != t) {LAB <- paste(LAB, style$relationship, ".", p, ".", t, " ~ ", VAR.prefix, style$relationship, ".", p, ".", t, "*", style$relationship, ".", p, ".", t, "\n", sep="")}#
	}#
}#
## ======================================================================#
## Put everything together#
## ======================================================================#
	## Add internal information about variable names etc.#
	SRM <- "### lavaan syntax for family SRM\n"#
	SRM <- paste(SRM, "### ROLES:'", paste(roles, collapse="','"), "'\n", sep="")#
	SRM <- paste(SRM, "### VARID:'", paste(var.id, collapse="','"), "'\n", sep="")#
	if (fe==TRUE) SRM <- paste(SRM, FE)#
	SRM <- paste(SRM, AE, PE, RE, ERR, GR, DR, LAB, sep="\n")#
	if (length(IGSIM) > 0) {SRM <- paste(SRM, igsim, sep="\n")}#
	if (self == TRUE) {SRM <- paste(SRM, SELF, sep="\n")}#
	if (addv!="") SRM <- paste(SRM, addv)#
	SRM <- paste(SRM, SM)#
	return(SRM)#
}#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2"), means=TRUE, err="no"))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))#
#
cat(buildSRMSyntaxLatent(c("m", "f", "c"), c("dep1", "dep2"), means=TRUE, fe=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/R')
cat(buildSRMSyntaxLatent(c("m", "f", "o", "y"), c("dep1", "dep2")))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s3 <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=TRUE)
cat(s3$model)
noc <- "#
### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
 # Family effect:#
FE =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*m_f_anx1 + 1*m_y_anx1 + 1*y_f_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*f_y_anx2 + 1*m_f_anx2 + 1*m_y_anx2 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
# A.f ~~ P.f#
# A.m ~~ P.m#
# A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
#
# Define labels for variances#
 FE ~ .VAR.FE*FE#
A.f ~ .VAR.A.f*A.f#
A.m ~ .VAR.A.m*A.m#
A.y ~ .VAR.A.y*A.y#
P.f ~ .VAR.P.f*P.f#
P.m ~ .VAR.P.m*P.m#
P.y ~ .VAR.P.y*P.y#
R.f.m ~ .VAR.R.f.m*R.f.m#
R.f.y ~ .VAR.R.f.y*R.f.y#
R.m.f ~ .VAR.R.m.f*R.m.f#
R.m.y ~ .VAR.R.m.y*R.m.y#
R.y.f ~ .VAR.R.y.f*R.y.f#
R.y.m ~ .VAR.R.y.m*R.y.m#
"
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
summary(s4b$res)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4  <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, fe=TRUE, means=TRUE)
cat(s4$model)
noc <- "#
### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
 # Family effect:#
FE =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*m_f_anx1 + 1*m_y_anx1 + 1*y_f_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*f_y_anx2 + 1*m_f_anx2 + 1*m_y_anx2 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
# A.f ~~ P.f#
# A.m ~~ P.m#
# A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
## Compute structured means#
# Define labels for subsequent constraints#
 FE ~ xFE*1#
A.f ~ xA.f*1#
A.m ~ xA.m*1#
A.y ~ xA.y*1#
P.f ~ xP.f*1#
P.m ~ xP.m*1#
P.y ~ xP.y*1#
R.f.m ~ xR.f.m*1#
R.f.y ~ xR.f.y*1#
R.m.f ~ xR.m.f*1#
R.m.y ~ xR.m.y*1#
R.y.f ~ xR.y.f*1#
R.y.m ~ xR.y.m*1#
# set means of observed variables to zero#
 f_m_anx1 ~ 0#
f_y_anx1 ~ 0#
m_f_anx1 ~ 0#
m_y_anx1 ~ 0#
y_f_anx1 ~ 0#
y_m_anx1 ~ 0#
f_m_anx2 ~ 0#
f_y_anx2 ~ 0#
m_f_anx2 ~ 0#
m_y_anx2 ~ 0#
y_f_anx2 ~ 0#
y_m_anx2 ~ 0 #
#
# set constraints on means for identifiability#
 xA.f + xA.m + xA.y == 0#
 xP.f + xP.m + xP.y == 0#
 xR.f.m + xR.f.y == 0#
 xR.m.f + xR.m.y == 0#
 xR.y.f + xR.y.m == 0#
 xR.m.f + xR.y.f == 0#
 xR.f.m + xR.y.m == 0#
 xR.f.y + xR.m.y == 0#
"
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4b <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc)
summary(res$4b)
summary(s4b$res)
noc2 <- "#
### lavaan syntax for family SRM#
### ROLES:'f','m','y'#
### VARID:'anx1','anx2'#
 # Family effect:#
FE =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*m_f_anx1 + 1*m_y_anx1 + 1*y_f_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*f_y_anx2 + 1*m_f_anx2 + 1*m_y_anx2 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Actor effects:#
A.f =~ 1*f_m_anx1 + 1*f_y_anx1 + 1*f_m_anx2 + 1*f_y_anx2#
A.m =~ 1*m_f_anx1 + 1*m_y_anx1 + 1*m_f_anx2 + 1*m_y_anx2#
A.y =~ 1*y_f_anx1 + 1*y_m_anx1 + 1*y_f_anx2 + 1*y_m_anx2#
#
# Partner effects:#
P.f =~ 1*m_f_anx1 + 1*y_f_anx1 + 1*m_f_anx2 + 1*y_f_anx2#
P.m =~ 1*f_m_anx1 + 1*y_m_anx1 + 1*f_m_anx2 + 1*y_m_anx2#
P.y =~ 1*f_y_anx1 + 1*m_y_anx1 + 1*f_y_anx2 + 1*m_y_anx2#
#
# Relationship effects:#
R.f.m =~ 1* f_m_anx1 + 1* f_m_anx2#
R.f.y =~ 1* f_y_anx1 + 1* f_y_anx2#
R.m.f =~ 1* m_f_anx1 + 1* m_f_anx2#
R.m.y =~ 1* m_y_anx1 + 1* m_y_anx2#
R.y.f =~ 1* y_f_anx1 + 1* y_f_anx2#
R.y.m =~ 1* y_m_anx1 + 1* y_m_anx2#
#
# Method covariance: Correlations among all error terms of the same items:#
f_m_anx1 ~~ MF1*f_y_anx1#
f_m_anx1 ~~ MF2*m_f_anx1#
f_m_anx1 ~~ MF3*m_y_anx1#
f_m_anx1 ~~ MF4*y_f_anx1#
f_m_anx1 ~~ MF5*y_m_anx1#
f_y_anx1 ~~ MF6*m_f_anx1#
f_y_anx1 ~~ MF7*m_y_anx1#
f_y_anx1 ~~ MF8*y_f_anx1#
f_y_anx1 ~~ MF9*y_m_anx1#
m_f_anx1 ~~ MF10*m_y_anx1#
m_f_anx1 ~~ MF11*y_f_anx1#
m_f_anx1 ~~ MF12*y_m_anx1#
m_y_anx1 ~~ MF13*y_f_anx1#
m_y_anx1 ~~ MF14*y_m_anx1#
y_f_anx1 ~~ MF15*y_m_anx1#
f_m_anx2 ~~ MF16*f_y_anx2#
f_m_anx2 ~~ MF17*m_f_anx2#
f_m_anx2 ~~ MF18*m_y_anx2#
f_m_anx2 ~~ MF19*y_f_anx2#
f_m_anx2 ~~ MF20*y_m_anx2#
f_y_anx2 ~~ MF21*m_f_anx2#
f_y_anx2 ~~ MF22*m_y_anx2#
f_y_anx2 ~~ MF23*y_f_anx2#
f_y_anx2 ~~ MF24*y_m_anx2#
m_f_anx2 ~~ MF25*m_y_anx2#
m_f_anx2 ~~ MF26*y_f_anx2#
m_f_anx2 ~~ MF27*y_m_anx2#
m_y_anx2 ~~ MF28*y_f_anx2#
m_y_anx2 ~~ MF29*y_m_anx2#
y_f_anx2 ~~ MF30*y_m_anx2#
#
# Generalized reciprocity:#
# A.f ~~ P.f#
# A.m ~~ P.m#
# A.y ~~ P.y#
#
# Dyadic reciprocity:#
R.f.m ~~ R.m.f#
R.f.y ~~ R.y.f#
R.m.y ~~ R.y.m#
#
"
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/fSRM/inst/SRMwR-Test')
s4c <- fSRM(anx1/anx2 ~ pid*tid | id2, dat3, model=noc2)
summary(s4c$res)
install.packages("lavaan", repos="http://www.da.ugent.be", type="source")
